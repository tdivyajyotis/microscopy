<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Media Labeling Tool</title>
  <!-- UTIF.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #media-container { margin-bottom: 15px; }
    img, video { max-width: 90%; max-height: 500px; display: block; margin: auto; }
    button { margin: 5px; padding: 10px 20px; }
    #progress { margin-top: 15px; font-weight: bold; }
    #storage-controls { margin-top: 15px; }
  </style>
</head>
<body>
  <h2>Media Labeling Tool</h2>

  <div id="media-container"></div>

  <div id="controls">
    <button onclick="label('Pebrine')">Pebrine (P)</button>
    <button onclick="label('Bacteria')">Bacteria (B)</button>
    <button onclick="label('Clear')">Clear (C)</button>
    <button onclick="reject()">Reject (R)</button>
    <button onclick="nextFile()">Next File (N)</button>
  </div>

  <div id="progress"></div>
  <button onclick="downloadCSV()">Download CSV (S)</button>
  <div id="storage-controls">
    <button onclick="clearStorage()">Clear Local Storage</button>
  </div>

  <script>
    let mediaList = [];
    let currentIndex = 0;
    let results = [];
    let currentVideo = null;
    let isVideo = false;

    async function loadMedia() {
      const resp = await fetch("images.json");
      mediaList = await resp.json();

      // Restore progress from local storage
      const saved = localStorage.getItem("labelingState");
      if (saved) {
        try {
          const state = JSON.parse(saved);
          currentIndex = state.currentIndex || 0;
          results = state.results || [];
        } catch (e) { console.warn("Failed to parse saved state:", e); }
      }

      updateProgress();
      showMedia();
    }

    function saveState() {
      localStorage.setItem("labelingState", JSON.stringify({ currentIndex, results }));
    }

    function showMedia() {
      if (currentIndex >= mediaList.length) {
        document.getElementById("media-container").innerHTML = "<p>All files processed!</p>";
        return;
      }

      const item = mediaList[currentIndex];
      const container = document.getElementById("media-container");
      container.innerHTML = "";
      currentVideo = null;
      isVideo = false;

      const fileUrl = item.url.toLowerCase();

      if (fileUrl.endsWith(".jpg") || fileUrl.endsWith(".jpeg") || fileUrl.endsWith(".png")) {
        const img = document.createElement("img");
        img.src = item.url;
        container.appendChild(img);

      } else if (fileUrl.endsWith(".tif") || fileUrl.endsWith(".tiff")) {
        const img = document.createElement("img");
        img.alt = item.fileName;
        container.appendChild(img);

        fetch(item.url)
          .then(r => r.arrayBuffer())
          .then(buf => {
            const ifds = UTIF.decode(buf);
            UTIF.replaceIMG(img, ifds[0]); // render first page
          })
          .catch(err => {
            container.innerHTML = "<p>Failed to load TIFF: " + err + "</p>";
          });

      } else if (fileUrl.endsWith(".mp4") || fileUrl.endsWith(".webm") || fileUrl.endsWith(".ogg")) {
        const video = document.createElement("video");
        video.src = item.url;
        video.controls = true;
        video.preload = "metadata";
        container.appendChild(video);
        currentVideo = video;
        isVideo = true;

      } else {
        container.innerHTML = "<p>Unsupported file type: " + item.fileName + "</p>";
      }
    }

    function label(choice) {
      const item = mediaList[currentIndex];
      let timestamp = currentVideo ? currentVideo.currentTime.toFixed(2) : "";

      let row = {
        fileName: item.fileName,
        Timestamp: timestamp,
        Pebrine: choice === "Pebrine" ? "Pebrine" : "",
        Bacteria: choice === "Bacteria" ? "Bacteria" : "",
        Clear: choice === "Clear" ? "Clear" : ""
      };

      results.push(row);
      saveState();

      if (!isVideo) {
        currentIndex++;
        updateProgress();
        showMedia();
      }
    }

    function reject() { currentIndex++; updateProgress(); showMedia(); saveState(); }
    function nextFile() { currentIndex++; updateProgress(); showMedia(); saveState(); }

    function updateProgress() {
      document.getElementById("progress").textContent =
        `Progress: ${currentIndex}/${mediaList.length}`;
    }

    function downloadCSV() {
      let csv = "Filename,Timestamp,Pebrine,Bacteria,Clear\n";
      results.forEach(r => csv += `${r.fileName},${r.Timestamp},${r.Pebrine},${r.Bacteria},${r.Clear}\n`);
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "labels.csv";
      a.click();
      URL.revokeObjectURL(url);
    }

    function clearStorage() { localStorage.removeItem("labelingState"); alert("Local storage cleared."); }

    // Keyboard shortcuts
    document.addEventListener("keydown", e => {
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;
      switch (e.key.toLowerCase()) {
        case "p": label("Pebrine"); break;
        case "b": label("Bacteria"); break;
        case "c": label("Clear"); break;
        case "r": reject(); break;
        case "n": nextFile(); break;
        case "s": downloadCSV(); break;
      }
    });

    loadMedia();
  </script>
</body>
</html>
